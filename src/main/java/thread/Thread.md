1. 进程：程序（任务）的执行过程  --> 动态性
   持有资源（共享内存，共享文件）和线程     -->载体

2. 线程：是系统中最小的执行单元，同一进程有多个线程，线程共享进程的资源
3. 线程的交互：互斥，同步

* 互斥的实现：`synchronize`（intrinsic lock）
* 同步的实现：`wait（）`/`notify()`/`notifyAll()` (Object 对象的方法)
* 争用条件：当多个线程同时共享访问统一数据（内存区域）时，每个线程都尝试操作该数据，从而导致数据被破坏（corrupted），这种现象称为争用条件。

## 两种方式：
interface Runnable
class Thread
1. Runnable 方式可以避免 Thread 方式由于 Java 单继承特性带来的缺陷
2. Runnable 的代码可以被多个线程（Thread 实例）共享，适合多个线程处理统一资源的情况

## 线程的生命周期
1. 创建：新建一个线程对象，new
2. 就绪：创建了线程对象后，调用方了线程的 `start()` 方法（此时线程只是进入了线程队列，等待获取 CPU 服务，具备了运行的条件，但并不一定已经开始运行了）
3. 运行：处于就绪状态的线程，一旦获取了 CPU 资源，便进入到运行状态，开始执行 `run()` 方法里面的逻辑
4. 终止：线程的`run()`方法执行完毕，或者线程调用了`stop()`方法，线程便进入终止状态
5. 阻塞：一个正在执行的线程在某些情况下，由于某种原因而暂时让出了 CPU 资源，暂停了自己的执行，便进入了阻塞状态，如调用了`sleep()`方法
6. 守护线程：通过 `setDaemon(true)` 开启，必须在 `start()` 之前调用

## 线程可见性
* 可见性：一个线程对共享变量值的修改，能够及时地被其他线程看到
* 共享变量：如果一个变量在多个线程的工作内存中都存在副本，那么这个变量就是这几个线程的共享变量
* Java 内存模型（JMM）描述了 Java 程序中各种变量（线程共享变量）的访问规则，以及在 JVM 中将变量存储到内存和从内存中读取出变量这样的底层细节

### 2条规定：
1. 线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写
2. 不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成


### 共享变量可见性实现的原理
线程1对共享变量的修改要想被线程2及时看到，必须经过如下2个步骤：
1. 把工作内存1中更新过的共享变量刷新到主内存中
2. 将主内存中最新的共享变量的值更新到工作内存2中

### Java关于synchronized的两条规定
1. 线程解锁钱，必须把共享变量的最新值刷新到主内存中
2. 线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值（注意：加锁与解锁需要是同一把锁）

### `synchronized`实现可见性
线程执行互斥代码的过程：
1. 获得互斥锁
2. 清空工作内存
3. 从主内存拷贝变量的最新副本到工作内存
4. 执行代码
5. 将更改后的共享变量的值刷新到主内存
6. 释放互斥锁

### 重排序
重排序：代码书写的顺序与实际执行的顺序不同，指令重排序是编译器或处理器为了提高程序性能而做的优化
1. 编译器优化的重排序（编译器优化）
2. 指令级并行重排序（处理器优化）
3. 内存系统的重排序（处理器优化）

`as-if-serial`：无论如何重排序，程序运行的结果应该与代码顺序执行的结果一致（Java编译器、运行时和处理器都会保证 Java 在单线程下遵循 as-if-serial 语义）

> Java Memory Mode
> Locks & Condition
> 线程安全性
> 多线程编程常用的交互模型
> Java5中并发编程工具
> core Java
> Java concurrency in practice